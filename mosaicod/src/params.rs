//! Module containing several parameters used across the codebase
//!
//! These parameter can be either constants or configurable via environment variables
//! but they are not expected to change during runtime.
//! For retrieving parameters that can be configured during startup (with env variables),
//! see the [`load_configurables_from_env`] function and the [`configurables`] accessor.

/// Defines the name of the `timestamp` column in the arrow schema
pub const ARROW_SCHEMA_COLUMN_NAME_TIMESTAMP: &str = "timestamp_ns";

/// Internal resolution for floating point comparisons
pub const EPSILON: f64 = 1.0e-06;

/// Name of the default layer
pub const DEFAULT_LAYER_NAME: &str = "default";
pub const DEFAULT_LAYER_DESCRIPTION: &str =
    "Default layer, this layer is automatically generated by mosaico at startup";

// /// Limit in the encoding/decoding message size
// pub const MAX_MESSAGE_SIZE_IN_BYTES: usize = 50 * 1024 * 1024;
// /// TODO: make thge
// pub const TARGET_MESSAGE_SIZE_IN_BYTES: usize = 25 * 1024 * 1024;

/// Module containing several file extensions
pub mod ext {
    /// Json file extension
    pub const JSON: &str = "json";
    pub const PARQUET: &str = "parquet";
}

use std::{env, str::FromStr, sync::OnceLock};

#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error("unable to parse variable `{0}`")]
    UnableToParse(String),
    #[error("unable to retrieve variable `{0}`, error: {1}")]
    RetrieveError(String, String),
}

#[derive(Debug)]
pub struct ConfigurablesParams {
    pub max_message_size_in_bytes: usize,
    pub target_message_size_in_bytes: usize,
}

static ENV: OnceLock<ConfigurablesParams> = OnceLock::new();

pub fn configurables() -> &'static ConfigurablesParams {
    ENV.get().expect("paramenters not initializes, plase call params::load_variable() before accessing and env variable.")
}

pub fn load_configurables_from_env() {
    let ev = ConfigurablesParams {
        max_message_size_in_bytes: cast_env_var(
            "MOSAICO_MAX_MESSAGE_SIZE_IN_BYTES",
            (50 * 1024 * 1024) as usize,
        ),
        target_message_size_in_bytes: cast_env_var(
            "MOSAICO_TARGET_MESSAGE_SIZE_IN_BYTES",
            25 * 1024 * 1024,
        ),
    };

    let _ = ENV.set(ev);
}

fn cast_env_var<T>(name: &str, default: T) -> T
where
    T: std::str::FromStr,
    <T as FromStr>::Err: std::fmt::Debug,
{
    let value = env::var(name);
    if value.is_err() {
        return default;
    }
    value
        .unwrap()
        .parse()
        .unwrap_or_else(|_| panic!("unable to parse variable `{}`", name))
}

pub fn require_env_var<T>(name: &str) -> Result<T, Error>
where
    T: std::str::FromStr,
    <T as FromStr>::Err: std::fmt::Debug,
{
    let value = env::var(name).map_err(|e| Error::RetrieveError(name.into(), e.to_string()))?;

    let t = value
        .parse()
        .map_err(|_| Error::UnableToParse(name.into()))?;

    Ok(t)
}

/// This staruct is used to hold sensitive information that should not be
/// printed in logs or debug output.
#[derive(Clone)]
pub struct Hidden(String);

impl Hidden {
    pub fn get(&self) -> &String {
        &self.0
    }

    pub fn take(self) -> String {
        self.0
    }
}

impl From<String> for Hidden {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::fmt::Debug for Hidden {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "**********")
    }
}

impl std::fmt::Display for Hidden {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "**********")
    }
}
